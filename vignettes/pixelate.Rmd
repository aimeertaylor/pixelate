---
title: "Pixelate spatial predictions"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pixelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
csl: vancouver.csl
---

<!-- https://www.zotero.org/styles -->
 
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.align = "center", 
  fig.height = 5, fig.width = 7, 
  out.width = "100%",
  dev = 'png', dpi = 3000
)
```

# Introduction 

This R package centres around a single function, `pixelate`, designed to pixelate predictions as per their average uncertainty. 

# Setup

In addition to **pixelate** we attach the **ggplot2** package for plotting 

```{r setup}
# Install devtools from CRAN if required
if (!require("devtools")) install.packages("devtools") 

# Attach required packages
library(pixelate)
library(ggplot2)
```

# Overview and quick example

<!-- Work out if there are any other frameworks under which spatial predictions with uncertainty estimates can be made -->

In brief, the function `pixelate` groups point estimates into a specified number of large pixels; computes the average uncertainty within each large pixel; then, for each large pixel, depending on its average uncertainty, either averages the point estimates across it or across smaller pixels nested within it. 

The resulting map is deliberately and selectively pixelated, similar to a photo that is pixelated to disguise a person's identity. Areas of high average uncertainty in the pixelated map are unresolved, while areas with low average uncertainty are resolved, similar to information poor versus rich regions of a satellite image. 

For full details of the function `pixelate` see its documentation, which is accessed by `?pixelate` or `help(pixelate)`, and the code for the functions on which it depends, which can be found in pixelate_internal_functions.R under the R/ directory of the installed package (use `find.package('pixelate')` to locate the installed package) or online [github.com/artaylor85/pixelate](https://github.com/artaylor85/pixelate). 

The function `pixelate` supports spatially continuous point estimates on any topic providing that they have associated measures of uncertainty. We illustrate its utility using predicted *Plasmodium falciparum* incidence @weiss2019 and can plot the output using functions from gglpot2 @ggplot2 as illustrated succinctly below and in more detail in the step-by-step example that follows. 

As the warning generated by `pixelate` states, there are issues around averaging uncertainty generated by a per-pixel simulation @gething:10. Importantly, this is a problem with the imput of `pixelate`, not the basis of `pixelate` itself. For the sake of illustration, we thus proceed with the pixelation of predicted *P. falciparum* incidence, despite uncertainty based on per-pixel simulation, while making a call for more jointly estimated uncertainty estimates as in @gething:10.  
 
<!-- Its output could be plotted using any of the various geographic information systems available. -->
<!-- available at the Malaria Atlas Project (MAP) website [map.ox.ac.uk](https://map.ox.ac.uk/) -->

```{r quick_example}
# To use pixelate, simply input some spatial predictions and plot the output; see code below. 
# To better understand the versatility of `pixelate` and reproduce plots in the README file, 
# follow the step-by-step detailed example in the next section.  

# Set options to supress the warnings etc. 
px <- pixelate(SubSaharanAfrica_Pf_incidence, verbose = FALSE)
ggplot(px$pix_matrix) + geom_raster(mapping = aes(x = x, y = y, fill = pix_z))
```


# Step-by-step detailed example

## Before we begin: a wrapper function to reproduce plots 

To avoid duplicating code over multiple plots, let us first define a wrapper `plot_sp_pred` for functions from the package **gglpot2** @ggplot2. 

To enhance plots, we add country borders using shape file data (see `?SubSaharanAfrica_shp` or `help(SubSaharanAfrica_shp)`). They are not essential. The shape file data were obtained using the function `malariaAtlas::getShp` from the malariaAtlas package @malariaAtlas; see get_shape_files.R in data-raw/ available online.


```{r}
#============================================================
# Function to plot spatial predictions, wrapping many 
# functions from ggplot2
#============================================================
plot_sp_pred = function(sp_pred, shp_file){
  
  p = ggplot() +
    
    # Raster surface
    geom_raster(data = sp_pred, mapping = aes(x = x, y = y, fill = z)) +
    ylab('Latitude') + xlab('Longitude') +
    
    # Set the limits of the plot using coord_sf before adding shape file
    coord_sf(xlim = round(range(sp_pred$x)),
                      ylim = round(range(sp_pred$y)),
                      expand = FALSE) +
    
    # Country borders
    geom_polygon(data = shp_file, aes(x = long, y = lat, group = group), 
                          fill = NA, colour = "black") +
    
    # Modify legend and add border:
    theme(legend.justification = c(0,0),
                   legend.position = c(0.01,0.01),
                   legend.background = element_rect(fill = NA),
                   legend.title = element_text(size=8),
                   legend.text = element_text(size=8),
                   panel.border = element_rect(linetype = "dashed", fill = NA))
  
  return(p)
}
```


## Step 1: get and format spatial predictions 

The function `pixelate` supports spatial predictions on any topic, e.g. residual contamination from nuclear weapon testing @diggle1998, providing that that they have associated measures of uncertainty. To use it, simply format your point estimates and their uncertainty measures and coordinates as per the example data set, SubSaharanAfrica_Pf_incidence, described and visualised below. A minimum of two by four (or four by two) predictions are necessary for pixelation by two or more large pixels. 

We illustrate the utility of `pixelate` using spatial predictions of malaria incidence rate in 2017. Specifically, we downloaded summaries extracted from per-pixel simulations of the posterior predictive *P. falciparum* incidence rates by selecting "ANNUAL MEAN OF PF INCIDENCE" at [map.ox.ac.uk/malaria-burden-data-download/](https://map.ox.ac.uk/malaria-burden-data-download/). We formatted the downloads using the script format_pf_incidence.R in the data-raw/ directory of the pixelate source package (the development version of the pixelate package). The data-raw/ directory is not available in the installed pixelate package, but it is available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw). 
(As an aside, the unformatted incidence predictions are too large to store in data-raw/ online, but they can be downloaded and formatted using the abovementioned MAP link and script format_pf_incidence.R. The R package malariaAtlas @malariaAtlas provides a direct R interface to parasite rate point estimates and MAP rasters via `malariaAtlas::getPR` and `malariaAtlas::getRaster`. However, at the time of writing, uncertainty measures were not available via the malariaAtlas package.) 

The formatted incidence predictions are included in the installed pixelate package. The first six predictions are printed below. Indespensibly, each has four variables associated with it (a longitude, x; a latitude, y; a point estimate, z; and an uncertainty measure, u); see `?SubSaharanAfrica_Pf_incidence` or `help(SubSaharanAfrica_Pf_incidence)` for more details. In our example, the point estimate, z, is the median of [a per-pixel simulation - check] from the posterior predictive distribution of the incidence rate, and the uncertainty measure, u, is the width of the 95\% credible interval (based on/estimated from?) [a per-pixel simulation - check] of the posterior predictive distribution of the incidence rate. Instead of taking the sample median and credible interval width as z and u, respectively, we could have taken the sample mean and standard standard deviation, say, or in a frequentist setting the maximum likelihood estimate of the mean incidence rate and its confidence interval. 


```{r}
head(SubSaharanAfrica_Pf_incidence)
```

```{r SubSaharanAfrica_unpixelated}
# Plot using the wrapper function defined above
p = plot_sp_pred(sp_pred = SubSaharanAfrica_Pf_incidence, 
                 shp_file = SubSaharanAfrica_shp) 
p + scale_fill_gradientn(name = "Predicted \nincidence rate", 
                                  colors = c("white", "red"), 
                                  na.value = 'lightblue')
```

```{r SubSaharanAfrica_uncertainty}
# To plot uncertainty, create a tempory spatial prediction and replace z by u 
temp_sp <- SubSaharanAfrica_Pf_incidence
temp_sp$z <- SubSaharanAfrica_Pf_incidence$u

# Plot using the wrapper function defined above
p = plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp)
p + scale_fill_gradientn(name = "Credible \ninterval width", 
                                  colors = c("white", "blue"), 
                                  na.value = 'lightblue')
```


## Step 2: pixelate spatial predictions using `pixelate`

```{r}
pix_output <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence)
```

Spatial predictions are input to `pixelate` via an arguement called dot_matrix. A dot refers to a single prediction (or is it the coordinates of a single prediction?) throughout the code and package documentation, whereas pixels refer to squares or rectangles comprised of one or more dots. The above call to pixelate implicitly relies on default values for a set of flexible pixelation arguments; see `?pixelate` to see what they are. 

The default values will fail if there are fewer than 400 by 400 predictions in the dot_matrix. To pixelate a dot_matrix with fewer predictions, reduce the number of large pixels (argument num_pix_xy_K) and the number of different pixel sizes (argument K). 

If the dot_matrix has more than 400 by 400 predictions, you can increase the number of large pixels and the number of different pixel sizes. For example, in the README file 
<!-- and ref to letter when publsihed -->
we display plots generated with XXX large pixels in the XXX direction and XXX different pixel sizes:

<!-- We should set the defaults to one number and the example to another in order to make vignette match README and manuscript -->

```{r, warning = FALSE, message = FALSE}
pix_output <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
                       num_pix_xy_bigk = 25, # Change from default, which is 20
                       bigk = 5) # Change from default, which is three
```

It is also possible to explore pixels that scale in size (dots per pixel) more rapidly by increasing the scale_factor argument and increasing the scale argument from linear to exponential. However, because the dots per pixel scale extremely rapidly when default pixelation arguments are increased, the prediction count required for seemingly modest argument combinations may exceed those available and thus generate an error, e.g. 

<!-- Note that purl = FALSE is essential in the following code block since it ensures this code block, which throws an error, is excluded from the vignette code document, allowing R to source and build the vignette without errors.  -->

```{r, error = TRUE, purl = FALSE}
pix_output <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
                       num_pix_xy_bigk = 25, # Default
                       bigk = 5, # Default
                       scale = 'exponential', # Change from default, which is 'linear'
                       scale_factor = 2) # Change from default, which is 1
```


## Step 3: plot the `pixelate`-ed output

```{r SubSaharanAfrica_pixelated, messages = FALSE}
# Re-create a temp matrix using pix_output
temp_sp <- pix_output$pix_matrix
temp_sp$z <- temp_sp$pix_z

p = plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_gradientn(name = "Predicted \nincidence rate", 
                                colors = c("white", "red"), 
                                na.value = 'lightblue')

p
```


To better understand the different pixel sizes, we can generate and add a pixel legend layer:

```{r SubSaharanAfrica_pixelated_with_legend}
gap_y <- 15 # Number of dots between example pixels and left edge of the plot
gap_x <- 350 # Number of dots from the bottom edge of the plot 
pix_legend_matrix <- pix_output$pix_matrix # Copy coordinates
pix_legend_matrix$z <- NA # Set z to NA 
bigk <- nrow(pix_output$dpp) # Extract the number of pixel sizes

csy <- cumsum(pix_output$dpp$y) 
xs <- sort(unique(pix_legend_matrix$x))
ys <- sort(unique(pix_legend_matrix$y))

for(k in 2:bigk){
  ind_y <- (gap_y*k + csy[k] + 1):(gap_y*k + csy[k] + pix_output$dpp$y[k])
  ind_x <- (gap_x + 1):(gap_x + pix_output$dpp$x[k])
  inds <- which(pix_legend_matrix$x %in% xs[ind_x] & pix_legend_matrix$y %in% ys[ind_y])
  pix_legend_matrix$pix_z[inds] <- 0
}

# Remove all the NAs
pix_legend <- pix_legend_matrix[!is.na(pix_legend_matrix$z), ]

# Add pixel size legend with title (alternative code annotate("rect", xmin, xmax, ymin, ymax))
p_plus_legend = p + geom_tile(data = pix_legend, mapping = aes(x = x, y = y, fill = pix_z)) +
  annotate("text", 
                    x = min(pix_legend$x), 
                    y = max(pix_legend$y) + 1.5,
                    label = "Multi-dot pixel sizes", 
                    size = 2.5, hjust = 0)

# Plot 
p_plus_legend
```

As mention above `pixelate` works by grouping point estimates into a specified number of large pixels and for each large pixel either averaging point estimates across it or across smaller pixels nested within it, depending on its averaged uncertainty. Specifically, each large pixel is allocated a pixel size (equal or nested) depending on which quantile interval its averaged uncertainty falls into, where the number of quantile intervals is equal to the number of different pixel sizes, and the quantiles are based on the empirical distribution of average uncertainty. We can plot these allocations to see how uncertainty varies across large pixels (i.e. how large pixels are allocated): 

```{r SubSaharanAfrica_bins}
# Make the plotted out put the pixel size allocated
temp_sp$z = as.factor(pix_output$pix_matrix$bins)

# Print plot (make legend more informative)
plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_discrete(name="Large pixel \nallocation", 
                               na.value = 'lightblue')
```

```{r, echo = FALSE}
# Save plots for manuscript
png(filename = 'pixelate_example.png')
p_plus_legend
dev.off()
```

# References

