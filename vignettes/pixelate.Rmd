---
title: "Pixelate"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pixelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
csl: vancouver.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, # Switch of all messages
  collapse = TRUE,
  comment = "> ", # To match console 
  fig.align = "center", 
  fig.height = 5, fig.width = 7, 
  out.width = "100%",
  dev = 'png', dpi = 300
)
```

# Introduction 

The R package **pixelate** centres around a single function, `pixelate`, designed to pixelate spatial predictions as per their average uncertainty. 

In brief, the function `pixelate` groups point estimates into a specified number of large pixels; computes the average uncertainty within each large pixel; then, for each large pixel, depending on its average uncertainty, either averages the point estimates across it or across smaller pixels nested within it. 

The plot of pixelated spatial predictions is deliberately and selectively pixelated, similar to a photo that is pixelated to disguise a person's identity. Areas of high average uncertainty in the pixelated plot are unresolved, while areas with low average uncertainty are resolved, similar to information poor versus rich regions of a satellite map. 

For full details of the function `pixelate` see its documentation accessed by `?pixelate` or `help(pixelate)` and the code for the functions on which it depends, which can be found in pixelate_internal_functions.R under the R/ directory of the source package, available online [github.com/artaylor85/pixelate/R/](https://github.com/artaylor85/pixelate/tree/master/R). 

The function `pixelate` supports spatially continuous predictions on any topic providing that they have associated measures of uncertainty. Its output could be plotted using any of the various geographic information systems available. We illustrate its utility using predicted *Plasmodium falciparum* incidence @weiss2019 and plot its output in R using functions from the **gglpot2** package @ggplot2. 

As the warning generated by `pixelate` in the quick example below states, there are issues around averaging uncertainty generated by a so-called 'per-pixel' simulation @gething:10, where 'per-pixel' is synonymous with 'per-prediction' (by constrast, a pixel refers to a collection of one or more predictions in **pixelate**). This is a problem with the input to `pixelate` not the basis of `pixelate`. As such, for the sake of illustration, we proceed with the pixelation of predicted *P. falciparum* incidence generated by a 'per-pixel' simulation, while calling for more jointly simulated predictions as in @gething:10.  

# Setup

```{r, warning = FALSE}
# Load and attach required packages
library(pixelate) 

if (!require("ggplot2")) {
  stop("Package ggplot2 needed to build this vignette. Please install it.")
}
```

# Quick example 
 
To use `pixelate`, simply input some spatial predictions and plot the output as follows. To better understand the versatility of `pixelate` and to generate refined plots follow the detailed example in the next section.  

```{r quick_example, fig.cap = "Pixelated *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. Pixelation was performed using default arguments."}
px <- pixelate(SubSaharanAfrica_Pf_incidence) # pixelate 
ggplot(px$pix_matrix) + geom_raster(mapping = aes(x = x, y = y, fill = pix_z)) # plot
```


# Detailed example

## Define a wrapper function for plotting

Before we begin, to avoid duplicating code over multiple plots, let us define a function, 
`plot_sp_pred`, that wraps various calls to functions from the package **gglpot2** @ggplot2. 

The `plot_sp_pred` function generates a raster plot with country borders if possible. 
Country borders enhance plots but are inessential.
We attempt to add them using shape file data and 
functions `ggplot2::geom_polygon` and `ggplot2::coord_sf`. 
The latter requires the **sf** package whose installation can be problematic. 
To ensure the code runs for all, including those who have problems with the installation of **sf**, 
we check for the availability of **sf** and generate plots accordingly,
with and without country borders. 

<!-- Specifically, the function `ggplot::coord_sf` depends on the **sf** package 
that depends on the **units** package and others, which can be problematic to install.  
The **sf** package is suggested by **ggplot2**. It is not a dependency 
of **ggplot2**, presumably because **sf** can be problematic to install
due to its dependencies (e.g. **units**) --->

Shape file data (see e.g. `?SubSaharanAfrica_shp`) were obtained using the function `malariaAtlas::getShp` from the malariaAtlas package @malariaAtlas; see get_shape_files.R in the data-raw/ directory of the source package, available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw).

```{r}
# Function to wrap many functions from ggplot2
plot_sp_pred = function(sp_pred, shp_file){
  
  p <- ggplot() +
    
    # Raster surface
    geom_raster(data = sp_pred, mapping = aes(x = x, y = y, fill = z)) +
    ylab('Latitude (degrees)') + xlab('Longitude (degrees)') + 
    
    # Modify the legend and add a plot border:
    theme(legend.justification = c(0, 0),
          legend.position = c(0.02, 0.01),
          legend.background = element_rect(fill = NA),
          legend.title = element_text(size = 8),
          legend.text = element_text(size = 8),
          panel.border = element_rect(fill = NA))  
    
  # Check the availablity of package sf (needed for ggplot2::coord_sf) 
  # and proceed accordingly. Note that requireNamespace("sf") is FALSE
  # if sf is available but one of its dependencies (e.g. units) is not
  if (requireNamespace("sf")) { 
    
    # Set the limits of the plot using coord_sf before adding shape file data 
    p <- p + coord_sf(xlim = round(range(sp_pred$x)),    
                     ylim = round(range(sp_pred$y)),
                     expand = FALSE) +
      
      # Country borders based on shape file data
      geom_polygon(data = shp_file, aes(x = long, y = lat, group = group), 
                   fill = NA, colour = "black")  
  } else {
    p <- p + coord_fixed(expand = FALSE) 
  }
  
  return(p)
}
```


## Get and format spatial predictions 

The function `pixelate` supports spatially continuous predictions on any topic providing that they have associated measures of uncertainty @diggle1998. To use `pixelate`, simply format your spatial predictions, uncertainty measures and coordinates as per the example data set, `SubSaharanAfrica_Pf_incidence`, described in more detail below. A minimum of eight predictions (two by four or four by two) are necessary for pixelation by two or more large pixels. 

We illustrate the utility of `pixelate` using spatial predictions of the *P. falciparum* malaria incidence rate in 2017 @weiss2019, which is available at the Malaria Atlas Project (MAP) website [map.ox.ac.uk](https://map.ox.ac.uk/). Specifically, we downloaded posterior predictive summaries of *P. falciparum* incidence rates by selecting "ANNUAL MEAN OF PF INCIDENCE" at [map.ox.ac.uk/malaria-burden-data-download/](https://map.ox.ac.uk/malaria-burden-data-download/). We formatted the downloads using the script format_pf_incidence.R in the data-raw/ director of the source package, available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw). 

<!-- The unformatted incidence predictions are too large to store in data-raw/ online, but they can be downloaded and formatted using the abovementioned MAP link and script format_pf_incidence.R. ---> 

(As an aside, the R package malariaAtlas @malariaAtlas provides a direct R interface to parasite rate point estimates and MAP rasters via `malariaAtlas::getPR` and `malariaAtlas::getRaster`. However, at the time of writing, uncertainty measures were not available via the malariaAtlas package.) 

The formatted incidence predictions are included in the installed pixelate package. They are stored in a data.frame with a prediction per row and at least four variables: a longitude, x; a latitude, y; a point estimate, z; and an uncertainty measure, u; see `?SubSaharanAfrica_Pf_incidence` or `help(SubSaharanAfrica_Pf_incidence)` for more details. A selection of predictions that are neither zero (e.g. because they are on a mountain top) or NA (e.g. because they are in the ocean) is printed below.  

```{r, results = 'asis'}
# non-zero non-NA rows for illustration:
example_count = 5
knitr::kable(SubSaharanAfrica_Pf_incidence[32863:(32863+example_count),], row.names = FALSE, 
             caption = sprintf("A selection of %s spatial predictions.", example_count)) 
```

In our example z is the median of a 'per-pixel' posterior predictive simulation and u is the width of the 0.95\% credible interval (i.e. 0.025\% to 0.975\% quantile interval) of the 'per-pixel' posterior predictive simulation. 

(As an aside, instead of taking the sample median and credible interval width as z and u respectively, we could have taken other measures of centrality and uncertainty, e.g. the mean and standard deviation as in @van2019.)

Both z and u are plotted in turn below. The uncertainty, u, in predicted *P. falciparum* incidence is low in regions were there are epidemiological data and in regions where there are strong predictors of low transmission, e.g. high altitude.


```{r SubSaharanAfrica_unpixelated, fig.cap = "*P. falciparum* predicted incidence for 2017 in sub-Saharan Africa."}
# Set up the plot using plot_sp_pred
unpix <- plot_sp_pred(sp_pred = SubSaharanAfrica_Pf_incidence, 
                     shp_file = SubSaharanAfrica_shp) 

# Add gradient surface
unpix <- unpix + scale_fill_gradientn(name = "Median \nincidence rate", 
                                     colors = c("seashell", "tomato", "darkred"), 
                                     na.value = 'lightblue')

# Plot
unpix 
```

```{r SubSaharanAfrica_uncertainty, fig.cap = "Uncertainty of *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa."}
#  Create a temporary spatial prediction and replace z by u 
temp_sp <- SubSaharanAfrica_Pf_incidence
temp_sp$z <- SubSaharanAfrica_Pf_incidence$u

# Set up the plot using plot_sp_pred
uncrt <- plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp)

# Add gradient surface
uncrt <- uncrt + scale_fill_gradientn(name = "95% credible \ninterval width", 
                                  colors = c("seashell", "darkgray", "black"), 
                                  na.value = 'lightblue')
uncrt
```

## Pixelate spatial predictions using `pixelate`

Spatial predictions are input to `pixelate` via an argument called dot_matrix. A dot refers to a single prediction throughout the code and package documentation, whereas pixels refer to squares or rectangles comprised of one or more dots. Note that the above warning regards averaging uncertainty is silenced in the following examples.  

```{r, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence)
```

The above call to pixelate implicitly relies on default values for a set of pixelation arguments; see `?pixelate` to see what they are. The default values will fail if there are fewer than 80 by 80 totaling 6400 predictions in the dot_matrix. To pixelate a dot_matrix with fewer predictions, reduce the number of large pixels (argument num_pix_xy_bigk) and the number of different pixel sizes (argument bigk). If the dot_matrix has more than 80 by 80 predictions, you can increase the number of large pixels and the number of different pixel sizes:

<!-- We should set the defaults to one number and the example to another in order to make vignette match README and manuscript -->

```{r, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
               num_pix_xy_bigk = 25, # Change from default, which is 20
               bigk = 5) # Change from default, which is 3
```

It is also possible to explore pixels that scale in size (dots per pixel) more rapidly by increasing the scale_factor argument and changing the scale argument from linear to exponential. However, because the dots per pixel can scale extremely rapidly when default pixelation arguments are changed, the prediction count required for seemingly modest argument combinations may exceed those available and thus generate an error, e.g. 

<!-- Note that purl = FALSE is essential in the following code block since it ensures this code block, which throws an error, is excluded from the vignette code document, allowing R to source and build the vignette without errors.  -->

```{r, error = TRUE, purl = FALSE, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
               num_pix_xy_bigk = 25, # Change from default, which is 20
               bigk = 5, # Change from default, which is 3
               scale = 'exponential', # Change from default, which is 'linear'
               scale_factor = 2) # Change from default, which is 1
```


## Plot the `pixelate`-ed output

To better appreciate the different pixel sizes, we first generate a pixel size legend layer as follows:

```{r SubSaharanAfrica_pixelated_with_legend}
gap_y <- 20 # Number of dots between example pixels and left edge of the plot
gap_x <- 350 # Number of dots from the bottom edge of the plot 
pix_legend <- px$pix_matrix # Copy coordinates
pix_legend$z <- NA # Set z to NA 
bigk <- nrow(px$dpp) # Extract the number of pixel sizes 

csy <- cumsum(px$dpp$y) # Cumulatively add pixel sizes (dots per pixel, dpp)
xs <- sort(unique(pix_legend$x)) # Extract unique longitude (degrees)
ys <- sort(unique(pix_legend$y)) # Extract unique latitude (degrees)

for(k in 2:bigk){ # For each of the multi-dot pixel sizes
  ind_y <- gap_y*k + ((csy[k-1] + 1):csy[k]) # Indices of latitude of example pixels
  ind_x <- (gap_x + 1):(gap_x + px$dpp$x[k]) # Indices of longitude of example pixels
  inds <- which(pix_legend$x %in% xs[ind_x] & pix_legend$y %in% ys[ind_y]) # Indices in the dot matrix
  pix_legend$z[inds] <- 0 # Set centrality measure of examples pixels to zero
}

# Remove all NAs
pix_legend <- pix_legend[!is.na(pix_legend$z), ]
```

We then add the pixels size legend layer to a plot of the pixelated spatial predictions as follows. 

```{r, fig.cap = sprintf("Pixelated *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. The number of different pixel sizes was set to %s. The lower bound on the number of large pixels was set to %s in both longitude and latitude, resulting in %s and %s large pixels in longitude and latitude, respectively. All other arguments had default values.", px$args$bigk, px$args$num_pix_xy_bigk, ceiling(px$dot_matrix_dim['x']/px$dpp$x[bigk]), ceiling(px$dot_matrix_dim['y']/px$dpp$y[bigk]))}
# Create a temporary data frame and set z to pixelated z, pix_z
temp_sp <- px$pix_matrix
temp_sp$z <- temp_sp$pix_z

# Generate a plot of pixelated 
pix <- plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) 

# Add gradient and pixel size legend layer with title   
pix <- pix + scale_fill_gradientn(name = "Pixelated median \nincidence rate", 
                                 colors =  c("seashell", "tomato", "darkred"), 
                                 na.value = 'lightblue') + 
  geom_tile(data = pix_legend, mapping = aes(x = x, y = y, fill = z)) +
  annotate("text", x = min(pix_legend$x), y = max(pix_legend$y) + 1.5,
           label = "Multi-dot pixel sizes", 
           size = 2.5, hjust = 0)

# Plot 
pix
```


As mentioned above `pixelate` works by grouping point estimates into a specified number of large pixels and for each large pixel either averaging point estimates across it or across smaller pixels nested within it depending on its averaged uncertainty. Specifically, each large pixel is allocated a pixel size depending on which quantile interval its averaged uncertainty falls into, where the number of quantile intervals is equal to the number of different pixel sizes and the quantiles are based on the empirical distribution of average uncertainty. For example, in the above plot the different pixel sizes correspond to the following quantile intervals:

```{r}
# Define quantile intervals
qs <- names(px$uncertainty_breaks)
quantile_intervals <- sapply(2:(bigk+1), function(k){
  bounds <- qs[c(k-1,k)]
  paste(bounds, collapse = ' to ')
})

# Define average uncertainty intervals
avus <- format(px$uncertainty_breaks,digits = 2)
avuncertainty_intervals <- sapply(2:(bigk+1), function(k){
  bounds <- avus[c(k-1,k)]
  paste(bounds, collapse = ' to ')
})

pixel_table <- cbind(quantile_intervals, avuncertainty_intervals, px$dpp) 

knitr::kable(pixel_table, row.names = FALSE, 
             col.names = c("Quantile interval", "Average uncertainty", "Pixel width (dots)", "Pixel height (dots)"), 
             caption = sprintf("Attributes of %s different pixel sizes from small (top) to large (bottom)", px$args$bigk), 
             align = rep("c",ncol(pixel_table)))
```

We can plot the large pixel allocations to see how uncertainty varies across large pixels (i.e. which quantile interval each large pixel falls into): 

```{r SubSaharanAfrica_bins, fig.cap = "Average uncertainty quantile intervals of *P. falciparum* predicted incidence for 2017 for sub-Saharan Africa. All arguments had values as specified in the caption of the above plot."}
# Set the plotted output, z, equal to the large pixel average uncertainty quantile interval 
temp_sp$z <- as.factor(px$pix_matrix$bins)

# Print plot (make legend more informative)
plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_discrete(name="Average uncertainty \nquantile interval", 
                      na.value = 'lightblue', labels = c(quantile_intervals, 'NA')) 
```


```{r, echo = FALSE, eval = FALSE}
# To save plots (this code is not evaluated): 
png(filename <- 'pixelate_example_%d.png')
unpix
uncrt
pix_plus_legend
dev.off()
```


# References

<!-- see https://www.zotero.org/styles for citation styles -->
