---
title: "Pixelate"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pixelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
csl: vancouver.csl
---

<!-- https://www.zotero.org/styles -->
 
```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, # Switch of all messages
  collapse = TRUE,
  comment = "#>", # To match console 
  fig.align = "center", 
  fig.height = 5, fig.width = 7, 
  out.width = "100%",
  dev = 'png', dpi = 300
)
```

# Introduction 

The R package **pixelate** centres around a single function, `pixelate`, designed to pixelate spatial predictions as per their average uncertainty. 

In brief, the function `pixelate` groups point estimates into a specified number of large pixels; computes the average uncertainty within each large pixel; then, for each large pixel, depending on its average uncertainty, either averages the point estimates across it or across smaller pixels nested within it. 

The resulting map is deliberately and selectively pixelated, similar to a photo that is pixelated to disguise a person's identity. Areas of high average uncertainty in the pixelated map are unresolved, while areas with low average uncertainty are resolved, similar to information poor versus rich regions of a satellite image. 

For full details of the function `pixelate` see its documentation, accessed by `?pixelate` or `help(pixelate)`, and the code for the functions on which it depends, which can be found in pixelate_internal_functions.R under the R/ directory of the installed package (use `find.package('pixelate')` to locate the installed package) or online [github.com/artaylor85/pixelate](https://github.com/artaylor85/pixelate). 

The function `pixelate` supports spatially continuous point estimates on any topic providing that they have associated measures of uncertainty. Its output could be plotted using any of the various geographic information systems available. We illustrate its utility using predicted *Plasmodium falciparum* incidence @weiss2019 and plot its output in R using functions from the **gglpot2** package @ggplot2. 

As the warning generated by `pixelate` in the quick example below states (warnings are silenced thereafter), there are issues around averaging uncertainty generated by a per-pixel simulation @gething:10. This is a problem with the input of `pixelate`, not the basis of `pixelate`. As such, for the sake of illustration, we proceed with the pixelation of predicted *P. falciparum* incidence despite uncertainty based on per-pixel simulation, while calling for more jointly estimated uncertainty estimates as in @gething:10.  

<!-- Work out if there are any other frameworks under which spatial predictions with uncertainty estimates can be made -->

# Setup

```{r setup, eval = FALSE}
# Originally we encountered problems with dependencies required for `ggplot::coord_sf` 
# (see comments below). Setting build_vignettes = TRUE in `devtools::install_github`
# (see README) appears to solve this problem. It problems persist, revisit code below. 

# The function `ggplot::coord_sf`, requires the **sf** package that depends on the **units** package. 
# The package **sf** is suggested by **ggplot2** and **units** sometimes fails to install. 
# (e.g. see https://community.rstudio.com/t/trouble-installing-packages-in-the-quickstart/23800)
# If this happens, first install **units** as `type = binary` if required; 
# second install **sf** if required; and third, we install **ggplot2** if required.  

# Install packages from CRAN if required
if (!requireNamespace("units", quietly = TRUE)) install.packages("units", type = 'binary')
if (!requireNamespace("sf", quietly = TRUE)) install.packages("sf")
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2", dependencies = TRUE)
```

Attach packages **pixelate** and **ggplot2** as follows.

```{r}
# Attach required packages
library(pixelate)
library(ggplot2)
```

# Quick example 
 
To use `pixelate`, simply input some spatial predictions and plot the output as follows. To better understand the versatility of `pixelate` and to reproduce the plots that feature in XXX follow the step-by-step example in the next section.  

```{r quick_example, fig.cap = "Pixelated *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. Pixelation was performed using default arguments."}
px <- pixelate(SubSaharanAfrica_Pf_incidence) # pixelate
ggplot(px$pix_matrix) + geom_raster(mapping = aes(x = x, y = y, fill = pix_z)) # plot
```


# Step-by-step detailed example

## Step 0: define a wrapper function for plotting

Before we begin, to avoid duplicating code over multiple plots, let us define a function, `plot_sp_pred`, that wraps various calls to functions from the package **gglpot2** @ggplot2. 

To enhance plots within `plot_sp_pred`, we add country borders using shape file data; see `?SubSaharanAfrica_shp` or `help(SubSaharanAfrica_shp)`). They are not essential. The shape file data were obtained using the function `malariaAtlas::getShp` from the malariaAtlas package @malariaAtlas; see get_shape_files.R in the data-raw/ directory of the pixelate source package (the development version of the pixelate package). The data-raw/ directory is not available in the installed pixelate package, but it is available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw)


```{r}
# Function to wrap many functions from ggplot2
plot_sp_pred = function(sp_pred, shp_file){
  
  p = ggplot() +
    
    # Raster surface
    geom_raster(data = sp_pred, mapping = aes(x = x, y = y, fill = z)) +
    ylab('Latitude') + xlab('Longitude') +
    
    # Set the limits of the plot using coord_sf before adding shape file
    coord_sf(xlim = round(range(sp_pred$x)),    
                      ylim = round(range(sp_pred$y)),
                      expand = FALSE) +
    
    # Country borders based on shape file
    geom_polygon(data = shp_file, aes(x = long, y = lat, group = group), 
                          fill = NA, colour = "black") +
    
    # Modify the legend and add a border:
    theme(legend.justification = c(0,0),
                   legend.position = c(0.01,0.01),
                   legend.background = element_rect(fill = NA),
                   legend.title = element_text(size=8),
                   legend.text = element_text(size=8),
                   panel.border = element_rect(fill = NA))
  
  return(p)
}
```


## Step 1: get and format spatial predictions 

The function `pixelate` supports spatial predictions on any topic (e.g. residual contamination from nuclear weapon testing @diggle1998) providing that that they have associated measures of uncertainty. To use it, simply format your point estimates and their uncertainty measures and coordinates as per the example data set, `SubSaharanAfrica_Pf_incidence`, described and visualised below. A minimum of eight predictions (two by four or four by two) are necessary for pixelation by two or more large pixels. 

We illustrate the utility of `pixelate` using spatial predictions of the *P. falciparum* malaria incidence rate in 2017 @weiss2019 available from the the Malaria Atlas Project (MAP) website [map.ox.ac.uk](https://map.ox.ac.uk/). Specifically, we downloaded summaries extracted from per-pixel simulations of the posterior predictive *P. falciparum* incidence rates by selecting "ANNUAL MEAN OF PF INCIDENCE" at [map.ox.ac.uk/malaria-burden-data-download/](https://map.ox.ac.uk/malaria-burden-data-download/). We formatted the downloads using the script format_pf_incidence.R in the data-raw/ available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw). 

(As an aside, the unformatted incidence predictions are too large to store in data-raw/ online, but they can be downloaded and formatted using the abovementioned MAP link and script format_pf_incidence.R. The R package malariaAtlas @malariaAtlas provides a direct R interface to parasite rate point estimates and MAP rasters via `malariaAtlas::getPR` and `malariaAtlas::getRaster`. However, at the time of writing, uncertainty measures were not available via the malariaAtlas package.) 

```{r, echo = FALSE}
example_count = 5
```

The formatted incidence predictions are included in the installed pixelate package. They are stored in a data.frame with a prediction per row (obs = predictions) and at least four variables: a longitude, x; a latitude, y; a point estimate, z; and an uncertainty measure, u; see `?SubSaharanAfrica_Pf_incidence` or `help(SubSaharanAfrica_Pf_incidence)` for more details. A selection of `example_count` predictions that are neither zero (e.g. because they on a mountain top) or NA (e.g. because they are in the ocean) is printed below.  

```{r, results='asis'}
# non-zero non-NA rows for illustration:
knitr::kable(SubSaharanAfrica_Pf_incidence[32863:(32863+example_count),], row.names = FALSE, 
             caption = sprintf("A selection of %s spatial predictions.", example_count)) 
```

In our example, the point estimate, z, is the median of [a per-pixel simulation - check] from the posterior predictive distribution of the incidence rate, and the uncertainty measure, u, is the width of the 95\% credible interval (based on/estimated from?) [a per-pixel simulation - check] of the posterior predictive distribution of the incidence rate. Each is plotted in turn below. 

Note that the uncertainty in predicted *P. falciparum* incidence is low in regions were there are epidemiological data (can we add data points downloaded from MAP? Shpuld be possible for parasite rate, not sure about incidence) and in regions where there are strong predictors of transmission, e.g. altitude.

(As an aside, instead of taking the sample median and credible interval width as z and u, respectively, we could have taken the sample mean and standard standard deviation, say, or in a frequentist setting a maximum likelihood estimate of the mean incidence rate (?) and its confidence interval.)

```{r SubSaharanAfrica_unpixelated, fig.cap = "Median *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa."}
# Set up the plot using plot_sp_pred
unpix = plot_sp_pred(sp_pred = SubSaharanAfrica_Pf_incidence, 
                 shp_file = SubSaharanAfrica_shp) 



# Add gradient surface
unpix = unpix + scale_fill_gradientn(name = "Predicted \nincidence rate", 
                                  colors = c("seashell", "tomato", "darkred"), 
                                  na.value = 'lightblue')

# Plot
unpix 
```

```{r SubSaharanAfrica_uncertainty, fig.cap = "Uncertainty of *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa."}
# To plot uncertainty, create a tempory spatial prediction and replace z by u 
temp_sp <- SubSaharanAfrica_Pf_incidence
temp_sp$z <- SubSaharanAfrica_Pf_incidence$u

# Set up the plot using plot_sp_pred
uncrt = plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp)

# Add gradient surface
uncrt = uncrt + scale_fill_gradientn(name = "95% credible \ninterval width", 
                                  colors = c("seashell", "darkgray", "black"), 
                                  na.value = 'lightblue')
uncrt
```

## Step 2: pixelate spatial predictions using `pixelate`

Spatial predictions are input to `pixelate` via an arguement called dot_matrix. A dot refers to a single prediction (or is it the coordinates of a single prediction?) throughout the code and package documentation, whereas pixels refer to squares or rectangles comprised of one or more dots. 

```{r, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence)
```

The above call to pixelate implicitly relies on default values for a set of flexible pixelation arguments; see `?pixelate` to see what they are. The default values will fail if there are fewer than 80 by 80 totalling 6400 predictions in the dot_matrix. To pixelate a dot_matrix with fewer predictions, reduce the number of large pixels (argument num_pix_xy_bigk) and the number of different pixel sizes (argument bigk). If the dot_matrix has more than 80 by 80 predictions, you can increase the number of large pixels and the number of different pixel sizes:

<!-- We should set the defaults to one number and the example to another in order to make vignette match README and manuscript -->

```{r, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
               num_pix_xy_bigk = 25, # Change from default, which is 20
               bigk = 5) # Change from default, which is 3
```

It is also possible to explore pixels that scale in size (dots per pixel) more rapidly by increasing the scale_factor argument and increasing the scale argument from linear to exponential. However, because the dots per pixel scale extremely rapidly when default pixelation arguments are increased, the prediction count required for seemingly modest argument combinations may exceed those available and thus generate an error, e.g. 
<!-- Note that purl = FALSE is essential in the following code block since it ensures this code block, which throws an error, is excluded from the vignette code document, allowing R to source and build the vignette without errors.  -->

```{r, error = TRUE, purl = FALSE, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
               num_pix_xy_bigk = 25, # Change from default, which is 20
               bigk = 5, # Change from default, which is 3
               scale = 'exponential', # Change from default, which is 'linear'
               scale_factor = 2) # Change from default, which is 1
```


## Step 3: plot the `pixelate`-ed output

To better appreciate the different pixel sizes, we generate a pixel size legend layer:

```{r SubSaharanAfrica_pixelated_with_legend}
gap_y <- 20 # Number of dots between example pixels and left edge of the plot
gap_x <- 350 # Number of dots from the bottom edge of the plot 
pix_legend <- px$pix_matrix # Copy coordinates
pix_legend$z <- NA # Set z to NA 
bigk <- nrow(px$dpp) # Extract the number of pixel sizes

csy <- cumsum(px$dpp$y) 
xs <- sort(unique(pix_legend$x))
ys <- sort(unique(pix_legend$y))

for(k in 2:bigk){
  ind_y <- gap_y*k + ((csy[k-1] + 1):csy[k])
  ind_x <- (gap_x + 1):(gap_x + px$dpp$x[k])
  inds <- which(pix_legend$x %in% xs[ind_x] & pix_legend$y %in% ys[ind_y])
  pix_legend$z[inds] <- 0
}

# Remove all the NAs
pix_legend <- pix_legend[!is.na(pix_legend$z), ]
```

Thereafter, we can add the pixels size legend to a plot of the pixelated spatial predictions as follows. 

```{r, fig.cap = sprintf("Pixelated median *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. The number of different pixel sizes was set to %s. The lower bound on the number of large pixels was set to %s in both longitude and latitude, resulting in %s and %s large pixels in longitude and latitude, respectively. All other arguments had default values.", px$args$bigk, px$args$num_pix_xy_bigk, ceiling(px$dot_matrix_dim['x']/px$dpp$x[bigk]), ceiling(px$dot_matrix_dim['y']/px$dpp$y[bigk]))}

# Re-create a temp matrix using px
temp_sp <- px$pix_matrix
temp_sp$z <- temp_sp$pix_z

# Generate a plot of pixelated 
p = plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_gradientn(name = "Predicted, \npixelated \nincidence rate", 
                                colors =  c("seashell", "tomato", "darkred"), 
                                na.value = 'lightblue')

# Add pixel size legend with title (alternative code annotate("rect", xmin, xmax, ymin, ymax))
pix_plus_legend = p + geom_tile(data = pix_legend, mapping = aes(x = x, y = y, fill = z)) +
  annotate("text", x = min(pix_legend$x), y = max(pix_legend$y) + 1.5,
           label = "Multi-dot pixel sizes", 
           size = 2.5, hjust = 0)

# Plot 
pix_plus_legend
```

We can also print the different pixel sizes in a table as follows. 

```{r}
knitr::kable(px$dpp, row.names = FALSE, 
             col.names = c("Pixel width (dots)", "Pixel height (dots)"), 
             caption = sprintf("Dots per pixel for %s different pixel sizes", px$args$bigk), 
             align = c("c","c"))
```

As mentioned above `pixelate` works by grouping point estimates into a specified number of large pixels and for each large pixel either averaging point estimates across it or across smaller pixels nested within it, depending on its averaged uncertainty. Specifically, each large pixel is allocated a pixel size (equal or nested) depending on which quantile interval its averaged uncertainty falls into, where the number of quantile intervals is equal to the number of different pixel sizes and the quantiles are based on the empirical distribution of average uncertainty. For example, for the above example there were `px$args$bigk+1` quantiles as follows:

```{r}
Av_uncert_quantiles = data.frame(Probability = names(px$uncertainty_breaks), 
                                 Quantile = format(px$uncertainty_breaks,digits = 2))

knitr::kable(t(Av_uncert_quantiles), align = c("l","c"), col.names = rep(" ", px$args$bigk+1), 
             caption = "Quantiles of the average uncertainty empirical distribution.")
```

We can plot the large pixel allocations to see how uncertainty varies across large pixels (i.e. which quantile interval each large pixel falls into): 

```{r SubSaharanAfrica_bins, fig.cap = sprintf("Average uncertainty quantile intervals of *P. falciparum* predicted incidence for 2017 for sub-Saharan Africa. All arguments had values as specified in the caption of the above plot. The empirical distribution of uncertainty averaged over large pixels was split at %s quantiles: %s, as specified in the above table.", px$args$bigk+1, paste(format(px$uncertainty_breaks,digits = 2), collapse = " "))}

# Make the plotted output the pixel size allocated
temp_sp$z = as.factor(px$pix_matrix$bins)

# Define quantile intervals
qs = seq(0, 1, length.out = bigk + 1)
quantile_intervals = sapply(2:(bigk+1), function(k){
  bounds = qs[c(k-1,k)]
  paste(paste0(format(bounds),'%'), collapse = ' to ')
})

# Print plot (make legend more informative)
plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_discrete(name="Average uncertainty \nquantile interval", 
                      na.value = 'lightblue', labels = c(quantile_intervals, 'NA')) 
```


```{r, echo = FALSE, eval = FALSE}
# To save plots (this code is not evaluated): 
png(filename = 'pixelate_example_%d.png')
unpix
uncrt
pix_plus_legend
dev.off()
```


# References

