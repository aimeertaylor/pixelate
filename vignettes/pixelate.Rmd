---
title: "Pixelate"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pixelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
csl: vancouver.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, # Switch of all messages
  collapse = TRUE,
  comment = "#> ", # To match console 
  fig.align = "center", 
  fig.height = 5, fig.width = 7, 
  out.width = "100%",
  dev = 'png', dpi = 300
)
```

# Introduction 

The R package **pixelate** centres around a single function, `pixelate`, designed to pixelate spatial predictions as per their average uncertainty. 

In brief, the function `pixelate` groups predictions into a specified number of large pixels; computes the average uncertainty within each large pixel; then, for each large pixel, depending on its average uncertainty, either averages the predictions across it or across smaller pixels nested within it. These averaged predictions are then plotted.

The resulting plot of averaged predictions is selectively pixelated, similar to a photo that is deliberately pixelated to disguise a person's identity. Areas of high average uncertainty in the pixelated plot are unresolved, while areas with high average certainty are resolved, similar to information poor versus rich regions of a satellite map. 

For full details of the function `pixelate` see its documentation accessed by `?pixelate` or `help(pixelate)`, its code accessed by `pixelate` and the code for the functions on which it depends, which can be found in pixelate_internal_functions.R under the R/ directory of the source package, available online [github.com/artaylor85/pixelate/R/](https://github.com/artaylor85/pixelate/tree/master/R). 

The function `pixelate` supports spatially continuous predictions (e.g. those generated by a geostatistical @diggle1998 or geospatial model @hengl2018) on any topic providing that they have associated measures of uncertainty. Its output could be plotted using any of the various geographic information systems available. We illustrate its utility using predicted *Plasmodium falciparum* incidence @weiss2019 and plot its output in R using functions from the **ggplot2** package @ggplot2. 

As the warning generated by `pixelate` in the quick example below states, there are issues around averaging uncertainty generated by a so-called 'per-pixel' simulation @gething:10, where 'per-pixel' is synonymous with 'per-prediction' (whereas, in **pixelate**, a pixel refers to a collection of one or more predictions). This is a problem with the input to `pixelate` not the basis of `pixelate`. Predicted *P. falciparum* incidence is based on a posterior predictive simulation that approximates the joint posterior predictive distribution thus accounting for spatial covariance and enabling averaging of uncertainty [@gething:10; @weiss2019].  

While developing this R package, we became aware of an identically named function provided by the **Vizumap** package @vizumap. `Vizumap::pixelate` is designed to pixelate choropleth maps @lucchesi2017, whereas `pixelate::pixelate` is designed to pixelate spatially continuous predictions [@diggle1998; @hengl2018]. Within each region of the cloropleth map, `Vizumap::pixelate` works by randomly assigning each pixel a value sampled from the margin of error around the corresponding regional estimate (pixels are equally-sized across the entire map); see the vignette of **Vizumap** and @lucchesi2017 for more details. Another interesting and related article that discusses communicating uncertainty in general highlights the utility of exceedance probabilities (e.g. the probability that some prediction exceeds a threshold) @kuhnert2018. Exceedance probabilities (EPs) provide a very simple alternative to pixelation: 'EPs from a threshold provide one piece of information to the decision maker: a probability.' and so can convey useful information to decision makers in a single map, whether it is a cloropleth map or a map of spatially continuous predictions.

# Setup

```{r, warning = FALSE}
# Load and attach required packages
library(pixelate) 

if (!require("ggplot2")) {
  stop("Package ggplot2 is needed to build this vignette. Please install it.")
}
```

# Quick example 
 
To use `pixelate`, simply input some spatial predictions and plot the output as follows. Please follow the detailed example in the next section to better understand the versatility of `pixelate` and to generate prettier plots.  

```{r quick_example, fig.cap = "Pixelated *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. Pixelation was performed using default arguments."}
# Pixelate 
px <- pixelate(SubSaharanAfrica_Pf_incidence) 

# Plot
ggplot(px$pix_matrix) + geom_raster(mapping = aes(x = x, y = y, fill = pix_z)) 
```

# Detailed example

## Define a wrapper function for plotting

Before we begin, to avoid duplicating code over multiple plots, let's define a function, 
`plot_sp_pred`, that wraps various calls to functions from the package **ggplot2** @ggplot2. 

The `plot_sp_pred` function generates a raster plot with country borders if possible. 
Country borders enhance plots but are inessential.
We attempt to add them using shape file data and 
functions `ggplot2::geom_polygon` and `ggplot2::coord_sf`. 
The latter requires the **sf** package whose installation can be problematic because it may require some external packages. To ensure the code runs for all, including those who have problems with the installation of **sf**, we check for the availability of **sf** and generate plots accordingly,
with and without country borders. 

<!-- R packages like {sf}, {sp}, {rgdal}, {rgeos} may require some external packages, e.g. 
libudunits2.so --->

Shape file data (see e.g. `?SubSaharanAfrica_shp`) were obtained using the function `malariaAtlas::getShp` from the malariaAtlas package @malariaAtlas; see get_shape_files.R in the data-raw/ directory of the source package, available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw).

```{r}
# Function to wrap many functions from ggplot2
plot_sp_pred = function(sp_pred, shp_file, legend_position = c(0.02, 0.01)){
  
  p <- ggplot() +
    
    # Raster surface
    geom_raster(data = sp_pred, mapping = aes(x = x, y = y, fill = z)) +
    ylab('Latitude (degrees)') + xlab('Longitude (degrees)') + 
    
    # Modify the theme:
    theme(legend.justification = c(0, 0),
          legend.position = legend_position,
          legend.background = element_rect(fill = NA),
          legend.title = element_text(size = 8),
          legend.text = element_text(size = 8),
          text = element_text(family = "serif"))  
  
  # Check the availability of package sf (needed for ggplot2::coord_sf) 
  # and proceed accordingly. Note that requireNamespace("sf") is FALSE
  # if sf is available but one of its dependencies (e.g. units) is not
  if (requireNamespace("sf")) { 
    
    # Set the limits of the plot using coord_sf 
    p <- p + coord_sf(xlim = range(sp_pred$x),    
                      ylim = range(sp_pred$y),
                      expand = FALSE) +
      
      # Add country borders based on shape file data
      geom_polygon(data = shp_file, aes(x = long, y = lat, group = group), 
                   fill = NA, colour = "gray30", size = 0.1)  
  } else {
    p <- p + coord_fixed(expand = FALSE) 
  }
  return(p)
}
```


## Get and format spatial predictions 

The function `pixelate` supports spatially continuous predictions on any topic providing that they have associated measures of uncertainty. To use `pixelate`, simply format your spatial predictions, uncertainty measures and coordinates as per the example data sets described in more detail below. A minimum of eight predictions (two by four or four by two) are necessary for pixelation by two or more large pixels. 

We illustrate the utility of `pixelate` using spatial predictions of *P. falciparum* malaria incidence in 2017 @weiss2019, which are available at the Malaria Atlas Project (MAP) website [map.ox.ac.uk](https://map.ox.ac.uk/). Specifically, we downloaded posterior predictive summaries of *P. falciparum* incidence rates by selecting "ANNUAL MEAN OF PF INCIDENCE" at [map.ox.ac.uk/malaria-burden-data-download/](https://map.ox.ac.uk/malaria-burden-data-download/). We formatted the downloads using the script format_pf_incidence.R in the data-raw/ directory of the source package, available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw). 

<!-- The unformatted incidence predictions are too large to store in data-raw/ online, but they can be downloaded and formatted using the abovementioned MAP link and script format_pf_incidence.R. ---> 

(As an aside, the R package malariaAtlas @malariaAtlas provides a direct R interface to parasite predictions and MAP rasters via `malariaAtlas::getPR` and `malariaAtlas::getRaster`. However, at the time of writing, uncertainty measures were not available via the malariaAtlas package.) 

The formatted incidence predictions are included in the installed pixelate package. They are stored in a data.frame with a prediction per row and four variables: a longitude, x; a latitude, y; a prediction, z; and an uncertainty measure, u; for more details see `?SubSaharanAfrica_Pf_incidence` and `?CentralAfrica_Pf_incidence`, where the latter is simply a cropped version of the former. A selection of predictions that are neither zero (e.g. because they are on a mountain top) or NA (e.g. because they are in the ocean) is printed below.  

```{r, results = 'asis'}
example_count = 5
knitr::kable(CentralAfrica_Pf_incidence[1:example_count,], row.names = FALSE, 
             caption = sprintf("A selection of %s spatial predictions and associated variables.", example_count)) 
```

In our example z is the median and u is the width of the 0.95\% credible interval. 

(As an aside, instead of taking the median and credible interval width as z and u respectively, we could have taken other measures of location and uncertainty, e.g. the mean and standard deviation as in @van2019.)

Both z and u are plotted in turn below. But first let's create a box to delineate the central Africa region that features in the example data set `CentralAfrica_Pf_incidence`: 

```{r CA box}
CA_box = CentralAfrica_Pf_incidence
CA_box = data.frame(x = c(min(CA_box$x), min(CA_box$x), 
                          max(CA_box$x), max(CA_box$x), min(CA_box$x)),
                    y = c(min(CA_box$y), max(CA_box$y), 
                          max(CA_box$y), min(CA_box$y), min(CA_box$y)),
                    id = rep(1,5))
```

```{r SubSaharanAfrica_unpixelated, fig.cap = "*P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. The box delineates the central Africa region that features in the pixelated plot of central Africa."}
# Set up the plot using plot_sp_pred
unpix <- plot_sp_pred(sp_pred = SubSaharanAfrica_Pf_incidence, 
                     shp_file = SubSaharanAfrica_shp) 

# Add gradient 
unpix <- unpix + scale_fill_gradientn(name = "Median \nincidence", 
                                     colors = c("seashell", "tomato", "darkred"), 
                                     na.value = 'lightblue2') + 
  # Add box
  geom_polygon(data = CA_box, aes(x = x, y = y, group = id), fill = NA,
               colour = "black", size = 0.5)

# Plot
unpix 
```

```{r SubSaharanAfrica_uncertainty, fig.cap = "Uncertainty of *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. The box delineates the central Africa region that features in the pixelated plot of central Africa."}
#  Create a temporary spatial prediction data frame and replace z by u 
temp_sp <- SubSaharanAfrica_Pf_incidence
temp_sp$z <- SubSaharanAfrica_Pf_incidence$u

# Set up the plot using plot_sp_pred
uncrt <- plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp)

# Add gradient 
uncrt <- uncrt + scale_fill_gradientn(name = "95% credible \ninterval width", 
                                  colors = c("seashell", "darkgray", "black"), 
                                  na.value = 'lightblue2') + 
  
  # Add box
  geom_polygon(data = CA_box, aes(x = x, y = y, group = id), fill = NA,
               colour = "black", size = 0.5)

# Plot
uncrt
```

Uncertainty in predicted *P. falciparum* incidence (figure above) is low in regions were there are epidemiological data and in regions where there are strong predictors of incidence. 

## Pixelate spatial predictions using `pixelate`

Spatial predictions are input into `pixelate` via an argument called dot_matrix. A dot refers to a set containing a single prediction throughout the code and package documentation, whereas pixels refer to squares or rectangles comprised of one or more predictions and thus dots. Note that the warning regards averaging uncertainty is silenced in the following examples.  

```{r, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence)
```

The above call to pixelate implicitly relies on default values for a set of pixelation arguments; see `?pixelate` to see what they are. The default values will fail if there are fewer than 480 by 480 predictions in the dot_matrix. To pixelate a dot_matrix with fewer predictions, reduce the number of large pixels (argument num_pix_xy_bigk) and/or the number of different pixel sizes (argument bigk): 

```{r, warning = FALSE}
px_CA <- pixelate(dot_matrix = CentralAfrica_Pf_incidence,
                  num_pix_xy_bigk = 12) # Change from default, which is 15
```

If the dot_matrix has more than 480 by 480 predictions, you can increase the number of large pixels and/or the number of different pixel sizes:


```{r, warning = FALSE}
px_SSA <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
                   num_pix_xy_bigk = 20) # Change from default, which is 15
```

It is also possible to explore pixels that scale in size (dots per pixel) more rapidly by increasing the scale_factor argument and changing the scale argument from linear to exponential. However, because the dots per pixel can scale extremely rapidly when default pixelation arguments are changed, the prediction count required for seemingly modest argument combinations may exceed those available and thus generate an error, e.g. 

<!-- Note that purl = FALSE is essential in the following code block since it ensures this code block, which throws an error, is excluded from the vignette code document, allowing R to source and build the vignette without errors.  -->

```{r, error = TRUE, purl = FALSE, warning = FALSE}
px <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
               scale = 'exponential', # Change from default, which is 'linear'
               scale_factor = 2) # Change from default, which is 1
```


## Plot the `pixelate`-ed output

To better appreciate the different pixel sizes, we first generate a pixel size legend layer as follows:

```{r pixel legend}
gap_y <- 20 # Number of dots between example pixels and left edge of the plot
gap_x <- 350 # Number of dots from the bottom edge of the plot 
pix_legend <- px_SSA$pix_matrix # Copy coordinates
pix_legend$z <- NA # Set z to NA 
bigk <- nrow(px_SSA$dpp) # Extract the number of pixel sizes 

csy <- c(0,cumsum(px_SSA$dpp$y)) # Cumulatively add pixel sizes (dots per pixel, dpp)
xs <- sort(unique(pix_legend$x)) # Extract unique longitude (degrees)
ys <- sort(unique(pix_legend$y)) # Extract unique latitude (degrees)

for(k in 1:bigk){ # For each of the pixel sizes
  ind_y <- gap_y*k + ((csy[k] + 1):csy[k+1]) # Indices of latitude of example pixels
  ind_x <- (gap_x + 1):(gap_x + px_SSA$dpp$x[k]) # Indices of longitude of example pixels
  
  # Indices in the dot matrix
  inds <- which(pix_legend$x %in% xs[ind_x] & pix_legend$y %in% ys[ind_y]) 
  pix_legend$z[inds] <- 0 # Set location measure of example pixel predictions to zero
}

# Remove all NAs
pix_legend <- pix_legend[!is.na(pix_legend$z), ]
```

We then add the pixels size legend layer to a plot of the pixelated spatial predictions as follows. 

```{r, fig.cap = sprintf("Pixelated *P. falciparum* predicted incidence for 2017 in sub-Saharan Africa. The lower bound on the number of large pixels was set to %s in both longitude and latitude, resulting in %s and %s large pixels in longitude and latitude, respectively. All other arguments had default values.", px_SSA$arguments$num_pix_xy_bigk, ceiling(px_SSA$dot_matrix_dim['x']/px_SSA$dpp$x[bigk]), ceiling(px_SSA$dot_matrix_dim['y']/px_SSA$dpp$y[bigk]))}
# Create a temporary data frame and set z to pixelated z, pix_z
temp_sp <- px_SSA$pix_matrix
temp_sp$z <- temp_sp$pix_z

# Generate a pixelated plot
pix_SSA <- plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) 

# Add gradient 
pix_SSA <- pix_SSA + scale_fill_gradientn(name = "Average median \nincidence", 
                                 colors =  c("seashell", "tomato", "darkred"), 
                                 na.value = 'lightblue2') + 
  
  geom_tile(data = pix_legend, mapping = aes(x = x, y = y, fill = z)) +
  annotate("text", x = min(pix_legend$x), y = max(pix_legend$y) + 1.5,
           label = "Pixel sizes", family = "serif", 
           size = 2.5, hjust = 0) 

# Plot 
pix_SSA
```

Following the example above, we can plot the bespoke pixelation of the central Africa region (i.e. pixelation of the predictions within the boxed region of the unpixelated plot as per the uncertainties within the boxed region of the uncertainty plot): 

```{r, fig.cap = sprintf("Pixelated *P. falciparum* predicted incidence for 2017 in the central Africa region. The lower bound on the number of large pixels was set to %s in both longitude and latitude, resulting in %s and %s large pixels in longitude and latitude, respectively. All other arguments had default values.", px_CA$arguments$num_pix_xy_bigk, ceiling(px_CA$dot_matrix_dim['x']/px_CA$dpp$x[bigk]), ceiling(px_CA$dot_matrix_dim['y']/px_CA$dpp$y[bigk]))}

# Pixel size legend
gap_y <- 5 # Number of dots between example pixels and left edge of the plot
gap_x <- 5 # Number of dots from the bottom edge of the plot
pix_legend <- px_CA$pix_matrix # Copy coordinates
pix_legend$z <- NA # Set z to NA
bigk <- nrow(px_CA$dpp) # Extract the number of pixel sizes

csy <- c(0,cumsum(px_CA$dpp$y)) # Cumulatively add pixel sizes (dots per pixel, dpp)
xs <- sort(unique(pix_legend$x)) # Extract unique longitude (degrees)
ys <- sort(unique(pix_legend$y)) # Extract unique latitude (degrees)

for(k in 1:bigk){ # For each of the pixel sizes
  ind_y <- gap_y*k + ((csy[k] + 1):csy[k+1]) # Indices of latitude of example pixels
  ind_x <- (gap_x + 1):(gap_x + px_CA$dpp$x[k]) # Indices of longitude of example pixels
  
  # Indices in the dot matrix
  inds <- which(pix_legend$x %in% xs[ind_x] & pix_legend$y %in% ys[ind_y]) 
  pix_legend$z[inds] <- 0 # Set centrality measure of examples pixels to zero
}

# Remove all NAs
pix_legend <- pix_legend[!is.na(pix_legend$z), ]

# Create a temporary data frame and set z to pixelated pix_z
temp_sp <- px_CA$pix_matrix
temp_sp$z <- temp_sp$pix_z

# Generate a plot of pixelated
pix_CA <- plot_sp_pred(sp_pred = temp_sp, shp_file = CentralAfrica_shp, 
                       legend_position = "right")


# Add gradient and pixel size legend layer with title
pix_CA <- pix_CA + scale_fill_gradientn(name = "Average \nmedian \nincidence",
                                         colors =  c("seashell", "tomato", "darkred"),
                                         na.value = 'lightblue2') +
  
  geom_tile(data = pix_legend, mapping = aes(x = x, y = y, fill = z)) +
  annotate("text", x = min(pix_legend$x), y = max(pix_legend$y) + 0.8,
           label = "Pixel \nsizes", family = "serif",
           size = 2, hjust = 0)


# Add border 
pix_CA_border <- pix_CA + theme(panel.border = element_rect(colour = "black", fill = NA, size = 1))

# Plot
pix_CA_border 
```

Note that the pixelated plots of both sub-Saharan Africa and central Africa feature perfectly resolved blue and white regions. This is because, importantly, missing predictions (coloured blue) and predictions that are zero with certainty (coloured white) are excluded from the entire pixelation process (i.e. computation and classification of average uncertainty, and computation of average prediction across large or nested pixel sizes). Missing predictions and predictions that are zero with certainty thus appear exactly as they do in the unpixelated plot and the plot of uncertainty. 

## Understanding how average uncertainty relates to pixel size

As mentioned above `pixelate` works by grouping predictions into a specified number of large pixels and for each large pixel either averaging predictions across it or across smaller pixels nested within it depending on its average uncertainty. (These averaged predictions are then plotted.) Specifically, each large pixel is allocated a nested pixel size depending on which quantile interval its average uncertainty falls into, where the number of quantile intervals is equal to the number of different nested pixel sizes and the quantiles are based on the empirical distribution of average uncertainty. For example, in the pixelated plot of sub-Saharan Africa the different nested pixel sizes correspond to the quantile intervals as follows.

```{r}
# Extract bigk
bigk <- nrow(px_SSA$dpp)

# Define quantile intervals
qs <- format(as.numeric(gsub('%', '',names(px_SSA$uncertainty_breaks))), digits = 4)
qs <- sapply(qs, function(q){paste(q, "%", sep = "")})
quantile_intervals <- sapply(2:(bigk+1), function(k){
  bounds <- qs[c(k-1,k)]
  paste(bounds, collapse = ' to ')
})

# Define average uncertainty intervals
avus <- format(px_SSA$uncertainty_breaks, digits = 2)
avuncertainty_intervals <- sapply(2:(bigk+1), function(k){
  bounds <- avus[c(k-1,k)]
  paste(bounds, collapse = ' to ')
})

# Group together
pixel_table <- cbind(quantile_intervals, avuncertainty_intervals, px_SSA$dpp) 

# Generate table
knitr::kable(pixel_table, row.names = FALSE, 
             col.names = c("Quantile interval", 
                           "Average uncertainty", 
                           "Nested pixel width (dots)", 
                           "Nested pixel height (dots)"), 
             align = rep("c",ncol(pixel_table)))
```

We can plot the large pixel allocations to see how uncertainty varies across large pixels (i.e. which quantile interval each large pixel falls into): 

```{r SubSaharanAfrica_bins, fig.cap = "Average uncertainty quantile intervals of *P. falciparum* predicted incidence for 2017 for sub-Saharan Africa. All arguments had values as specified in the caption of the pixelated plot of sub-Saharan plot."}
# Set z equal to the large pixel average uncertainty quantile interval index
temp_sp <- px_SSA$pix_matrix
temp_sp$z <- as.factor(px_SSA$pix_matrix$bins)

# Generate and print the plot
plot_sp_pred(sp_pred = temp_sp, shp_file = SubSaharanAfrica_shp) +
  scale_fill_discrete(name="Average uncertainty \nquantile interval", 
                      na.value = 'lightblue2', labels = c(quantile_intervals, 'NA')) 
```

From the plot and table of quantile intervals, we can see that coral regions have high certainty and thus predictions in these regions of the pixelated plot of sub-Saharan Africa are not averaged (the nested pixels are one dot by one dot). Meanwhile predictions in the pixelated plot of sub-Saharan Africa that fall with green regions of the quantile plot are averaged over moderately sized nested pixels (six by six dots). Pink regions (that cover large parts of the Democratic Republic of the Congo) have high uncertainty; predictions in the pixelated plot of sub-Saharan Africa that fall within pink regions of the quantile plot are averaged across the entire large pixel, which is 48 by 48 dots. 


# References

<!-- see https://www.zotero.org/styles for citation styles -->
