---
title: "pixelate"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pixelate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ref.bib
csl: vancouver.csl
---

<!-- https://www.zotero.org/styles -->
 
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.align = "center", 
  fig.height = 5, fig.width = 7, 
  out.width = "100%", 
  dev = 'png', dpi = 300 # png and dpi = 300 ensure plots aer reasonably sized
)
```

```{r setup}
library(pixelate)
```

# Introduction 

This R package centres around a single function, `pixelate`, designed to pixelate spatially continuous point estimates (i.e./e.g. spatial predictions made by a geostatistical model on any topic) as per their average uncertainty. 

In brief, the function `pixelate` groups point estimates into a specified number of large pixels; computes the average uncertainty within each large pixel; then, for each large pixel, depending on its average uncertainty, either averages the point estimates across it or across smaller pixels nested within it. 

The resulting map is deliberately and selectively pixelated, similar to a photo that is selectively pixelated to disguise a person's identity. Areas of high average uncertainty in the pixelated map are unresolved, while areas with low average uncertainty are resolved, similar to information poor versus rich regions of a satellite image. 

For full details of the function `pixelate` see its documentation, which is accessed by `?pixelate` or `help(pixelate)`, and the code for the functions on which it depends, which can be found in pixelate_internal_functions.R under the R/ directory of the installed package (use `find.package('pixelate')` to locate the installed package) or online [github.com/artaylor85/pixelate](https://github.com/artaylor85/pixelate). 

The function `pixelate` supports spatially continuous point estimates on any topic providing that they have associated measures of uncertainty. We illustrate its utility using predicted *Plasmodium falciparum* incidence [REF paper] and plot the output using functions from packages gglpot2 @ggplot2 and sf @sf: 

<!-- Its output could be plotted using any of the various geographic information systems available. -->
<!-- available at the Malaria Atlas Project (MAP) website [map.ox.ac.uk](https://map.ox.ac.uk/) -->


```{r Quick example}
# To use pixelate, simply input some spatial predictions and plot the output; see code below. 
# To better understand the versatility of `pixelate` and reproduce the plots in the README file, 
# follow the step-by-step detailed example in the next section.  

pixd <- pixelate(SubSaharanAfrica_Pf_incidence)
ggplot2::ggplot() + ggplot2::geom_raster(pixd$pix_matrix, 
                                         mapping = ggplot2::aes(x = x, 
                                                                y = y, 
                                                                fill = pix_z))
```


# Step-by-step detailed example

# Before we begin: plotting 

To avoid duplicating code over multiple plots in the following example, let us define a function, `plot_spatial_predictions`, which wraps together functions from packages gglpot2 @ggplot2 and sf @sf. 

To enhance plots, we add country borders using shape file data that are cropped to the extent of the spatial predictions using bbox.sf. Country borders not essential. Nonethless, to ensure full reproducability of the code in this vignette, the shape file data and bbox.sf are included in the installed package (see `?SubSaharanAfrica_shp` or `help(SubSaharanAfrica_shp)`, and `?bbox.sf` or `help(bbox.sf)`, respectively). The shape file data were obtained using the function `malariaAtlas::getShp` from the malariaAtlas package @malariaAtlas; see get_shape_files.R in data-raw/ available online. The object bbox.sf was generated using code xxxl see XXX.R in data-raw/ available online. An alternative approach for plotting partial shape files within the confines of a raster images uses geom_tile, but is very slow.


```{r}
#============================================================
# Wrapper function to plot spatial predictions
# Note that geom_sf() throws and  intermittent error: "polygon edge not found"
# see link: https://github.com/tidyverse/ggplot2/issues/2252
#============================================================
plot_spatial_predictions = function(spatial_predictions, shape_file, bbox.sf, 
                                    gradient.colors = c("white","red"), 
                                    na.color = "lightblue", 
                                    legend.positions = c(0.01,0.01), 
                                    legend.text.size = 8,
                                    legend.title.text = "Predicted \nincidence rate"){
  p = ggplot2::ggplot() +
    
    # Raster surface
    ggplot2::geom_raster(data = spatial_predictions, mapping = ggplot2::aes(x = x, y = y, fill = z)) +
    ggplot2::scale_fill_gradientn(name = legend.title.text, colors = gradient.colors, na.value = na.color) +
    ggplot2::ylab('Latitude') + 
    ggplot2::xlab('Longitude') +
    
    # Country borders:
    ggplot2::geom_sf(data = bbox.sf, fill = NA) +
    ggplot2::coord_sf(xlim = c(sf::st_bbox(bbox.sf)['xmin'], 
                               sf::st_bbox(bbox.sf)['xmax']),
                      ylim = c(sf::st_bbox(bbox.sf)['ymin'], 
                               sf::st_bbox(bbox.sf)['ymax']), expand = FALSE) +
    ggplot2::geom_polygon(data = shape_file, ggplot2::aes(x = long, y = lat, group = group), fill = NA, colour = "black") +
    
    # Modify legend by changing the theme see ?theme
    ggplot2::theme(legend.justification = c(0,0),
                   legend.position = legend.positions,
                   legend.background = ggplot2::element_rect(fill=NA),
                   legend.title = ggplot2::element_text(size=legend.text.size),
                   legend.text = ggplot2::element_text(size=legend.text.size))
  
  return(p)
}
```


## Step 1: get and format spatial predictions 

The function `pixelate` supports spatial predictions on any topic, e.g. residual contamination from nuclear weapon testing @diggle1998, providing that that they have associated measures of uncertainty. To use it, simply format your point estimates and their uncertainty measures and coordinates as per the example data set, SubSaharanAfrica_Pf_incidence, described and visualised below. A minimum of XXX predictions are necessary for pixelation by two or more large pixels. 

We illustrate the utility of `pixelate` using spatial predictions of malaria incidence rate in 2017. Specifically, we downloaded summaries extracted from per-pixel simulations of the posterior predictive *P. falciparum* incidence rates by selecting "ANNUAL MEAN OF PF INCIDENCE" at [map.ox.ac.uk/malaria-burden-data-download/](https://map.ox.ac.uk/malaria-burden-data-download/). We formatted the downloads using the script format_pf_incidence.R in the data-raw/ directory of the pixelate source package (the development version of the pixelate package). The data-raw/ directory is not available in the installed pixelate package, but it is available online [github.com/artaylor85/pixelate/data-raw/](https://github.com/artaylor85/pixelate/tree/master/data-raw). 

(The unformatted incidence predictions are too large to store in data-raw/ online, but they can be downloaded and formatted using the abovementioned MAP link and script format_pf_incidence.R. The R package malariaAtlas @malariaAtlas provides a direct R interface to parasite rate point estimates and MAP rasters via `malariaAtlas::getPR` and `malariaAtlas::getRaster`. However, at the time of writing, uncertainty measures were not available via the malariaAtlas package.) 

The formatted incidence predictions are included in the installed pixelate package. The first six predictions are printed below. Indespensibly, each has five variables associated with it (a longitude, x; a latitude, y; a point estimate, z; and an uncertainty measure, u); see `?SubSaharanAfrica_Pf_incidence` or `help(SubSaharanAfrica_Pf_incidence)` for more details. In our example, the point estimate, z, is the median of [a per-pixel simulation - check] from the posterior predictive distribution of the incidence rate, and the uncertainty measure, u, is twice the (sample?) standard deviation of [a per-pixel simulation - check] of the posterior predictive distribution of the incidence rate. Instead of taking the sample median and standard deviation as z and u, respectively, we could have taken the sample mean and quantile width, say, or in a frequentist setting the maximum likelihood estimate of the mean incidence rate and its confidence interval. Finally, it's worth noting that there are some issues around averaging uncertainty measures generated by a per-pixel simulation; see section entitled Limitations below. 


```{r}
head(SubSaharanAfrica_Pf_incidence)
```

```{r SubSaharanAfrica_CI_width}
# Plot using the wrapper function defined above
plot_spatial_predictions(spatial_predictions = SubSaharanAfrica_Pf_incidence, 
                         bbox.sf, shape_file = SubSaharanAfrica_shp)
```

```{r SubSaharanAfrica_Unpixelated}
# Create a tempory spatial prediction data frame in order to replace z by u to plot u
temp_sp <- SubSaharanAfrica_Pf_incidence
temp_sp$z <- SubSaharanAfrica_Pf_incidence$u

# Plot using the wrapper function defined above
plot_spatial_predictions(temp_sp, bbox.sf, shape_file = SubSaharanAfrica_shp, 
                         gradient.colors = c("white", "blue"), 
                         legend.title.text = "Twice \nstandard deviation")
```


## Step 2: pixelate spatial predictions using `pixelate`

```{r}
pix_output <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence)
```

Spatial predictions are input to `pixelate` via an arguement called dot_matrix. A dot refers to a single prediction (or is it the coordinates of a single prediction?) throughout the code and package documentation, whereas pixels refer to squares or rectangles comprised of one or more dots. The above call to pixelate implicitly relies on default values for a set of flexible pixelation arguments; see `?pixelate` to see what they are. 

The default values will fail if there are fewer than xxx predictions in the dot_matrix. To pixelate a dot_matrix with fewer than xxx predictions, reduce the number of large pixels (argument num_pix_xy_K) and the number of different pixel sizes (argument K). 

If the dot_matrix has more than xxx predictions, you can increase the number of large pixels and the number of different pixel sizes. It is also possible to explore pixels that scale in size (dots per pixel) more rapidly and/or exponentially by increasing the scale_factor argument and increasing the scale argument from linear to exponential. However, because dots per pixel scale extremely rapidly when the default pixelation arguments are increased, even seemingly modest combinations may throw in an error because there are incompatible with the number of available predictions, e.g. 

<!-- Note that purl = FALSE is essential in the following code block since it ensures this code block, which throws an error, is excluded from the vignette code document, allowing R to source and build the vignette without errors.  -->

```{r, error = TRUE, purl = FALSE}
pix_output <- pixelate(dot_matrix = SubSaharanAfrica_Pf_incidence,
                       num_pix_xy_K = c(10L,10L),
                       K = 3L,
                       scale = "exponential",
                       scale_factor = 2L)
```


## Step 3: plot the `pixelate`-ed output


```{r}
# First let's generate a pixel legend layer for the plot of pix_output

gap_y <- 15 # Number of dots between example pixels and edge of the plot in the y-direction
gap_x <- 350 # Number of dots from the edge of the plot in the x-direction
pix_legend_matrix <- pix_output$pix_matrix
pix_legend_matrix$pix_z <- NA
K <- nrow(pix_output$dpp)
csy <- cumsum(pix_output$dpp$y)
xs <- sort(unique(pix_legend_matrix$x))
ys <- sort(unique(pix_legend_matrix$y))

for(k in 2:K){
  ind_y <- (gap_y*k + csy[k] + 1):(gap_y*k + csy[k] + pix_output$dpp$y[k])
  ind_x <- (gap_x + 1):(gap_x + pix_output$dpp$x[k])
  inds <- which(pix_legend_matrix$x %in% xs[ind_x] & pix_legend_matrix$y %in% ys[ind_y])
  pix_legend_matrix$pix_z[inds] <- 0
}

pix_legend <- pix_legend_matrix[!is.na(pix_legend_matrix$pix_z), ]
```

```{r SubSaharanAfrica_Pixelated}
# Re-create a temp matrix using pix_output
temp_sp <- pix_output$pix_matrix
temp_sp$z <- temp_sp$pix_z

pix_plot = plot_spatial_predictions(spatial_predictions = temp_sp, 
                                    bbox.sf, 
                                    shape_file = SubSaharanAfrica_shp)

# Add pixel size legend with title (alternative code annotate("rect", xmin, xmax, ymin, ymax))
pix_plot_legend = pix_plot + ggplot2::geom_tile(data = pix_legend, mapping = ggplot2::aes(x = x, y = y, fill = pix_z)) +
  ggplot2::annotate("text", x = min(pix_legend$x), y = max(pix_legend$y) + 1.5,
                    label = "Multi-dot pixel sizes", size = 2.5, hjust = 0)

pix_plot_legend 
```

Mention something about bins

```{r SubSaharanAfrica_bins}
pix_output$pix_matrix$bins = as.factor(pix_output$pix_matrix$bins)

bin_map = ggplot2::ggplot() + 
  
  # Raster surface:
  ggplot2::geom_raster(data = pix_output$pix_matrix, ggplot2::aes(x = x, y = y, fill = bins)) +
  ggplot2::scale_fill_discrete(name="pixel \nallocation") +
  ggplot2::ylab('Latitude') + 
  ggplot2::xlab('Longitude') +
  
  # Country borders:
  ggplot2::geom_sf(data = bbox.sf, fill = NA) +
  ggplot2::coord_sf(xlim = c(sf::st_bbox(bbox.sf)['xmin'], 
                             sf::st_bbox(bbox.sf)['xmax']),
                    ylim = c(sf::st_bbox(bbox.sf)['ymin'], 
                             sf::st_bbox(bbox.sf)['ymax']), expand = FALSE) +
  ggplot2::geom_polygon(data = SubSaharanAfrica_shp, 
                        ggplot2::aes(x = long, y = lat, group = group), 
                        fill = NA, colour = "black") + 
  
  # Modify legend:
  ggplot2::theme(legend.justification=c(0,0), 
                 legend.position = c(0.01,0.01), 
                 legend.background = ggplot2::element_rect(fill=NA),
                 legend.title = ggplot2::element_text(size=8), 
                 legend.text = ggplot2::element_text(size=8)) 

# Print plot
bin_map
```

# Limitations

Talk about per-pixel simulation

# References

