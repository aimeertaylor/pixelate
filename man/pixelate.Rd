% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pixelate.R
\name{pixelate}
\alias{pixelate}
\title{Pixelate as per average uncertainty}
\usage{
pixelate(dot_matrix, num_pix_xy_bigk = 15, bigk = 6L,
  scale = "linear", scale_factor = 1L)
}
\arguments{
\item{dot_matrix}{Data frame. Contains a row per spatial prediction with at least
four variables: longitude, x; latitude, y; point estimate, z; and uncertainty measure u.}

\item{num_pix_xy_bigk}{Integer or integer vector length two. Specifies the number of large
pixels in the x and y direction.}

\item{bigk}{Integer. Specifies the number of average uncertainty quantile intervals and
thus different pixel sizes to pixelate into.}

\item{scale}{String equal to either "linear" or "exponential". Specifies
whether to scale pixel sizes (in units of dots) from class k = 2,...,bigk
linearly or exponentially.}

\item{scale_factor}{Integer. Specifies a factor by which to either multiply
or exponentiate pixel sizes (in units of dots), depending on the scale.}
}
\value{
List.
\describe{
  \item{pix_matrix}{The original dot matrix with additional variables:
  average uncertainty, u_bigk; the average uncertainty quantile interval
  allocation, bins; and pixelated point estimate, pix_z.}
  \item{pix_matrix_expanded}{A spatially expanded dot matrix with additional
  variables: the average uncertainty, u_bigk; average uncertainty quantile
  interval allocation, bins; and pixelated point estimate, pix_z.}
  \item{uncertainty_breaks}{The values of average uncertainty at the bigk+1
  quantiles of the empirical distribution of average uncertainties.}
  \item{dpp}{The dots per pixel (dpp) for k = 1,...,bigk pixel sizes in the x
  and y direction.}
  \item{dot_matrix_dim}{The dimensions (in dots) of the
  original dot matrix.}
  \item{dot_mem}{A matrix of dot memberships, where each membership specifies
  which quantile interval that the large pixel containing the specified dot
  falls into.}
  \item{arguments}{The arguments passed to pixelate when it was called.}
}
}
\description{
Pixelate spatially continuous predictions as per their average uncertainties.
}
\details{
This is a wrapper function which, given a dot matrix and several arguments,
pixelates as follows. Let a dot denote a prediction with a set of
coordinates, a point estimate and uncertainty measure represented by a single
value, e.g. 95\% credible interval width. Let a pixel refer to a
square or rectangle comprising one or more dots. Uncertainties are averaged
over a limited number of large pixels (pixels of the bigk-th size). Average
uncertainties are classified as high, medium (with bigk-2 subdivisions), or
low, according to the quantile interval they fall into, where the number of
quantile intervals is equal to the number of different pixel sizes (bigk) and
the quantiles are based on the empirical distribution of average
uncertainties. If the average uncertainty is high (falls within the top
quantile interval), point estimates within the large pixel are averaged. If
the average uncertainty is intermediate (falls with an intermediate quantile
interval), point estimates within the large pixel are averaged over smaller
nested pixels. If the average uncertainty is low (falls within the bottom
quantile interval), point estimates are not averaged.
}
\examples{
#=================================================
# Use pixelate and inspect its output
#=================================================
# Pixelate using default parameters
px_def <- pixelate(SubSaharanAfrica_Pf_incidence)

# Inspect list returned by pixelate
str(px_def)

# Inspect a sample of uncertain pixelated predictions
uncertain_ind = which(px_def$pix_matrix$u > 0)
head(px_def$pix_matrix[uncertain_ind, ])

# Pixelate using alternative parameters
px_alt <- pixelate(SubSaharanAfrica_Pf_incidence,
                   num_pix_xy_bigk = 25, bigk = 5)


#=================================================
# Plotting pixelate's output
#=================================================
# Load and attach ggplot2
if (!require("ggplot2")){
   stop("Package ggplot2 needed for the following code. Please install it.")
}

# Define a plotting function
plot_sp_pred <- function(sp_pred){

 ggplot(sp_pred) +

   # Add raster surface
   geom_raster(mapping = aes(x = x, y = y, fill = pix_z)) +

   # Add gradient
   scale_fill_gradientn(name = "Median incidence rate",
                        colors = c("seashell", "tomato", "darkred"),
                        na.value = 'lightblue') +

   # Add axis labels
   ylab('Latitude (degrees)') +
   xlab('Longitude (degrees)') +

   # Ensure the plotting space is not expanded
   coord_fixed(expand = FALSE) +

   # Modify the legend and add a plot border:
   theme(legend.justification = c(0, 0),
         legend.position = c(0.02, 0.01),
         legend.background = element_rect(fill = NA),
         legend.title = element_text(size = 8),
         legend.text = element_text(size = 8),
         panel.border = element_rect(fill = NA))

}

# Plot default and alternative
plot_sp_pred(px_def$pix_matrix)
plot_sp_pred(px_alt$pix_matrix)

}
